task 1: In the driver file (main.cpp), perform the following sub-tasks.
1. Create two objects of this class, one with no constructor argument and one with the argument 5.
2. Take five input values from the user and store them in the array inside the second object using the set method.
3. For the second object, print all the values you just stored.
Note that, you cannot assign anything in the first object since the array inside it has size 0. Neither can you change 
the size of this array to some other size.
// dynarr.h
#ifndef DYNARR_H_INCLUDED
#define DYNARR_H_INCLUDED

// Class declaration for dynamic array
class dynArr {
private:
    int *data;  // Pointer to dynamically allocated array
    int size;   // Size of the array

public:
    // Constructors and Destructor
    dynArr();         // Default constructor
    dynArr(int s);    // Parameterized constructor
    ~dynArr();        // Destructor

    // Member functions
    void setValue(int index, int value);  // Set value at a specific index
    int getValue(int index);              // Get value at a specific index
};

#endif // DYNARR_H_INCLUDED

// dynarr.cpp
#include "dynarr.h"
#include <iostream>

using namespace std;

// Default constructor
dynArr::dynArr() {
    data = nullptr;  // Initialize pointer to null
    size = 0;        // Initialize size to zero
}

// Parameterized constructor
dynArr::dynArr(int s) {
    data = new int[s];  // Dynamically allocate memory for the array //pointer_variable = new data_type[size];//pointer_variable: The pointer variable that will store the address of the dynamically allocated memory.
//data_type: The data type of the elements in the array.
    size = s;           // Set the size of the array
}

// Destructor
dynArr::~dynArr() {
    delete[] data;  // Deallocate the dynamically allocated memory
}

// Get value at a specific index
int dynArr::getValue(int index) {
    return data[index];
}

// Set value at a specific index
void dynArr::setValue(int index, int value) {
    data[index] = value;
}
//main.cpp
#include "dynarr.h"
#include <iostream>

using namespace std;

int main() {
    // 1. Create two objects of the dynArr class
    dynArr obj1;        // Object with default constructor (size 0)
    dynArr obj2(5);      // Object with parameterized constructor (size 5)

    // 2. Take five input values from the user and store them in the array inside the second object
    cout << "Enter five values for the array in the second object:\n";
    for (int i = 0; i < 5; i++) {
        int value;
        cout << "Enter value " << i + 1 << ": ";
        cin >> value;
        obj2.setValue(i, value);
    }

    // 3. Print all the values stored in the array inside the second object
    cout << "Values stored in the array of the second object:\n";
    for (int i = 0; i < 5; i++) {
        cout << "Value " << i + 1 << ": " << obj2.getValue(i) << endl;
    }

    return 0;
}

task 2: Modify the header and the source files. Add a member function void allocate(int s) which allows
you to change the size of the array. Make sure that memory is not leaked
// dynarr.h
#ifndef DYNARR_H_INCLUDED
#define DYNARR_H_INCLUDED

class dynArr {
private:
    int *data;
    int size;

public:
    dynArr();
    dynArr(int);
    ~dynArr();
    void setValue(int, int);
    int getValue(int);
    void allocate(int);  // New member function to change the size of the array
};

#endif // DYNARR_H_INCLUDED
// dynarr.cpp
#include "dynarr.h"
#include <iostream>

using namespace std;

dynArr::dynArr() {
    //data = nullptr;
    size = 0;
}

dynArr::dynArr(int s) : size(s) {
    data = new int[size];
}

dynArr::~dynArr() {
    delete[] data;
}

void dynArr::setValue(int index, int value) {
    if (index >= 0 && index < size) {
        data[index] = value;
    }
}

int dynArr::getValue(int index) {
    if (index >= 0 && index < size) {
        return data[index];
    }
    return -1; // or handle the out-of-bounds case accordingly
}

void dynArr::allocate(int s) {
    // Deallocate existing memory
    delete[] data;

    // Allocate new memory with the specified size
    size = s;
    data = new int[size];
}

#include "dynarr.h"
#include <iostream>

using namespace std;

int main() {
    // Create an object with no constructor argument (size 0)
    dynArr obj1;

    // Create an object with the argument 5
    dynArr obj2(5);

    // Set values in the array of the second object
    cout << "Enter five values for the array in the second object:\n";
    for (int i = 0; i < 5; i++) {
        int value;
        cout << "Enter value " << i + 1 << ": ";
        cin >> value;
        obj2.setValue(i, value);
    }

    // Display values in the array of the second object
    cout << "Values stored in the array of the second object:\n";
    for (int i = 0; i < 5; i++) {
        cout << "Value " << i + 1 << ": " << obj2.getValue(i) << endl;
    }

    // Change the size of the array in the second object
    int newSize;
    cout << "Enter the new size for the array in the second object: ";
    cin >> newSize;
    obj2.allocate(newSize);

    // Take input for the new array in the second object
    cout << "Enter values for the new array in the second object:\n";
    for (int i = 0; i < newSize; i++) {
        int value;
        cout << "Enter value " << i + 1 << ": ";
        cin >> value;
        obj2.setValue(i, value);
    }

    // Display the updated array in the second object
    cout << "Updated values in the array of the second object:\n";
    for (int i = 0; i < newSize; i++) {
        cout << "Value " << i + 1 << ": " << obj2.getValue(i) << endl;
    }

    return 0;
}

task 3 - Modify the header file and the source files again, so that it works for two dimensional array where all the 
rows are the same size. The user will specify the number of rows and columns as well as the content of the array, 
which you will take as input from user in the main function
// dynarr.h
#ifndef DYNARR_H_INCLUDED
#define DYNARR_H_INCLUDED

class dynArr {
private:
    int **data;  // Pointer to a pointer for a two-dimensional array
    int rows;
    int cols;

public:
    dynArr();
    dynArr(int r, int c);
    ~dynArr();
    void setValue(int row, int col, int value);
    int getValue(int row, int col);
    void allocate(int r, int c);
};

#endif // DYNARR_H_INCLUDED
// dynarr.cpp
#include "dynarr.h"
#include <iostream>

using namespace std;

dynArr::dynArr() : data(nullptr),rows(0), cols(0) {}

dynArr::dynArr(int r, int c) : rows(r), cols(c) {
    data = new int*[rows];  // Allocate an array of row pointers

    for (int i = 0; i < rows; ++i) {
        data[i] = new int[cols];  // Allocate each row separately
    }
}

dynArr::~dynArr() {
    // Deallocate memory for each row
    for (int i = 0; i < rows; ++i) {
        delete[] data[i];
    }

    // Deallocate memory for the array of row pointers
    delete[] data;
}

void dynArr::setValue(int row, int col, int value) {
    if (row >= 0 && row < rows && col >= 0 && col < cols) {
        data[row][col] = value;
    }
}

int dynArr::getValue(int row, int col) {
    if (row >= 0 && row < rows && col >= 0 && col < cols) {
        return data[row][col];
    }
    return -1; // or handle the out-of-bounds case accordingly
}

void dynArr::allocate(int r, int c) {
    // Deallocate existing memory
    for (int i = 0; i < rows; ++i) {
        delete[] data[i];
    }
    delete[] data;

    // Allocate new memory for the specified number of rows and columns
    rows = r;
    cols = c;

    data = new int*[rows];  // Allocate an array of row pointers

    for (int i = 0; i < rows; ++i) {
        data[i] = new int[cols];  // Allocate each row separately
    }
}
// main.cpp
#include <iostream>
#include "dynarr.h"

using namespace std;

int main() {
    // Task 1: Create Object
    int rows, cols;

    cout << "Enter the number of rows: ";
    cin >> rows;

    cout << "Enter the number of columns: ";
    cin >> cols;

    dynArr obj(rows, cols);

    // Task 2: Take User Input
    int input;
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            cout << "Enter value at row " << (i + 1) << ", column " << (j + 1) << ": ";
            cin >> input;
            obj.setValue(i, j, input);
        }
    }

    // Task 3: Print Stored Values
    cout << "Values stored in the object: \n";
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            cout << obj.getValue(i, j) << " ";
        }
        cout << endl;
    }

    return 0;
}





//Extra : do it for 2d array of rows of different length
// dynarr.h
#ifndef DYNARR_H_INCLUDED
#define DYNARR_H_INCLUDED

class dynArr {
private:
    int **data;  // Pointer to an array of pointers for a two-dimensional array with varying row sizes
    int *rowSizes;  // Array to store the size of each row
    int numRows;    // Number of rows

public:
    dynArr();
    dynArr(int r, int* sizes);
    ~dynArr();
    void setValue(int row, int col, int value);
    int getValue(int row, int col);
    void allocate(int r, int* sizes);
};

#endif // DYNARR_H_INCLUDED
// dynarr.cpp
#include "dynarr.h"
#include <iostream>

using namespace std;

dynArr::dynArr() : data(nullptr), rowSizes(nullptr), numRows(0) {}

dynArr::dynArr(int r, int* sizes) : numRows(r) {
    data = new int*[numRows];   // Allocate an array of row pointers
    rowSizes = new int[numRows]; // Allocate an array to store row sizes

    for (int i = 0; i < numRows; ++i) {
        rowSizes[i] = sizes[i];  // Store the size of each row
        data[i] = new int[rowSizes[i]];  // Allocate each row separately
    }
}

dynArr::~dynArr() {
    // Deallocate memory for each row
    for (int i = 0; i < numRows; ++i) {
        delete[] data[i];
    }

    // Deallocate memory for the array of row pointers and row sizes
    delete[] data;
    delete[] rowSizes;
}

void dynArr::setValue(int row, int col, int value) {
    if (row >= 0 && row < numRows && col >= 0 && col < rowSizes[row]) {
        data[row][col] = value;
    }
}

int dynArr::getValue(int row, int col) {
    if (row >= 0 && row < numRows && col >= 0 && col < rowSizes[row]) {
        return data[row][col];
    }
    return -1; // or handle the out-of-bounds case accordingly
}

void dynArr::allocate(int r, int* sizes) {
    // Deallocate existing memory
    for (int i = 0; i < numRows; ++i) {
        delete[] data[i];
    }
    delete[] data;
    delete[] rowSizes;

    // Allocate new memory for the specified number of rows and sizes
    numRows = r;

    data = new int*[numRows];   // Allocate an array of row pointers
    rowSizes = new int[numRows]; // Allocate an array to store row sizes

    for (int i = 0; i < numRows; ++i) {
        rowSizes[i] = sizes[i];  // Store the size of each row
        data[i] = new int[rowSizes[i]];  // Allocate each row separately
    }
}
// main.cpp
#include <iostream>
#include "dynarr.h"

using namespace std;

int main() {
    // Task 1: Create Object
    int numRows;

    cout << "Enter the number of rows: ";
    cin >> numRows;

    int* rowSizes = new int[numRows];

    cout << "Enter the size for each row:" << endl;
    for (int i = 0; i < numRows; ++i) {
        cout << "Size of row " << (i + 1) << ": ";
        cin >> rowSizes[i];
    }

    dynArr obj(numRows, rowSizes);

    // Task 2: Take User Input
    int input;
    for (int i = 0; i < numRows; ++i) {
        for (int j = 0; j < rowSizes[i]; ++j) {
            cout << "Enter value at row " << (i + 1) << ", column " << (j + 1) << ": ";
            cin >> input;
            obj.setValue(i, j, input);
        }
    }

    // Task 3: Print Stored Values
    cout << "Values stored in the object: \n";
    for (int i = 0; i < numRows; ++i) {
        for (int j = 0; j < rowSizes[i]; ++j) {
            cout << obj.getValue(i, j) << " ";
        }
        cout << endl;
    }

    // Cleanup
    delete[] rowSizes;

    return 0;
}


//Task 1: Recall the class we used in the previous lab to allocate memory dynamically. Modify the header file 
//and the source file given below so that they now work as template class (the array elements in the 
//dynamically allocated memory can be any type as the user defines).
 Include guard to prevent multiple inclusion of the header file
#ifndef DYNARR_H_INCLUDED
#define DYNARR_H_INCLUDED
// Declaration of the template class dynArr
template <class anything>
//template <class or typename T>
//class or typename declares a type parameter 
class dynArr
{
//Private data members: pointer to dynamically allocated memory and size of the array
private:
    anything *data;
    int size;
public:
    dynArr(int);
    ~dynArr();
    void setValue(int, anything);
    anything getValue(int);

};
#endif // DYNARR_H_INCLUDED
//Here, a template class dynArr is defined. It has private data members data (a pointer to anything) and size (an integer). The class also declares a constructor, destructor, and member functions to set and get values.




#include "dynarr.h"
#include <iostream>
using namespace std;
template <class anything>
//ClassName<T>::ConstructorName(Parameters)
dynArr<anything>::dynArr(int s)
{
    data = new anything[s];   //pointerVariable = new DataType[size];
    size = s;
}
//This is the constructor definition for the dynArr class. It dynamically allocates an array of type anything with size s and sets the size accordingly.
template <class anything>
dynArr<anything>::~dynArr()//The destructor definition. It deallocates the dynamically allocated memory when the object goes out of scope. i.e when its block or function in which it is declared ends
{
    delete [] data;
}
template <class anything>
//ReturnType ClassName<T>::FunctionName(ParameterType parameter)
anything dynArr<anything>::getValue(int index)//Definition of the member function getValue, which retrieves the value at the specified index in the array.
{
    return data[index];
}
template <class anything>
void dynArr<anything>::setValue(int index, anything value)//Definition of the member function setValue, which sets the value at the specified index in the array.
{
    data[index] = value;
}




#include <iostream>
#include "dynarr.h"
#include "dynarr.cpp"
using namespace std;
int main()
{

    dynArr<int> da1(5);//an instance da1 of the template class dynArr is created with the template parameter int with size 5
    cout<<"enter index and value"<<endl;
    int i, v;
    cin>>i;
    cin>> v;
    da1.setValue(i,v);
    cout<<da1.getValue(0)<<endl;//this will print garbage value since we have not yet set value at index 0
    dynArr<double> da2(5);//an instance da1 of the template class dynArr is created with the template parameter double with size 5
    da2.setValue(0,4.67);
    cout<<da2.getValue(0)<<endl;//4.67
    cout<<da1.getValue(i)<<endl;//value entered by user at the index i but if index is chosen more than 5 garbage value will be printed
    return 0;
}
//complex number
//complex.h
#ifndef COMPLEX_H_INCLUDED
#define COMPLEX_H_INCLUDED
class Complex
{
public:
    Complex();
    Complex(double, double);
    Complex operator+(Complex);
    void Print();
private:
    double Real, Imaginary;
};
#endif // COMPLEX_H_INCLUDED


//complex.cpp
#include "complex.h"
#include <iostream>
using namespace std;
Complex::Complex()
{
    Real = 0;
    Imaginary = 0;
}
Complex::Complex(double r, double i)
{
    Real = r;
    Imaginary = i;
}
Complex Complex::operator+(Complex a)
{
    Complex t;
    t.Real = Real + a.Real;
    t.Imaginary = Imaginary + a.Imaginary;
    return t;
}
void Complex::Print()
{
    cout << Real << endl;
    cout << Imaginary << endl;
}
// main.cpp

#include "complex.h"
#include <iostream>

int main() {
    // Code using Complex class
    Complex complex1(3.0, 4.0);
    Complex complex2(1.5, 2.5);
    Complex result = complex1 + complex2;
    result.Print();

    return 0;
}






//Task 2: Recall the complex number class we discussed in our lectures. Modify the class and overload the *
//(multiplication) and the != (not equal) operators for the class given below
// complex.h

#ifndef COMPLEX_H_INCLUDED
#define COMPLEX_H_INCLUDED

class Complex {
public:
    Complex();
    Complex(double, double);
    Complex operator+(const Complex&) const;  // Overloaded +
    Complex operator*(const Complex&) const;  // Overloaded *
    bool operator!=(const Complex&) const;    // Overloaded !=
    void Print() const;

private:
    double Real, Imaginary;
};

#endif // COMPLEX_H_INCLUDED


// complex.cpp

#include "complex.h"
#include <iostream>

Complex::Complex() {
    Real = 0;
    Imaginary = 0;
}

Complex::Complex(double r, double i) {
    Real = r;
    Imaginary = i;
}

Complex Complex::operator+(const Complex& a) const {
    Complex t;
    t.Real = Real + a.Real;
    t.Imaginary = Imaginary + a.Imaginary;
    return t;
}

Complex Complex::operator*(const Complex& a) const {
    Complex t;
    t.Real = (Real * a.Real) - (Imaginary * a.Imaginary);
    t.Imaginary = (Real * a.Imaginary) + (Imaginary * a.Real);
    return t;
}

bool Complex::operator!=(const Complex& a) const {
    return (Real != a.Real) || (Imaginary != a.Imaginary);
}

void Complex::Print() const {
    std::cout << "Real: " << Real << std::endl;
    std::cout << "Imaginary: " << Imaginary << std::endl;
}


// main.cpp

#include "complex.h"
#include <iostream>

int main() {
    // Create two Complex objects
    Complex complex1(3.0, 4.0);
    Complex complex2(1.5, 2.5);

    // Use the overloaded + operator to add the two complex numbers
    Complex resultAddition = complex1 + complex2;

    // Use the overloaded * operator to multiply the two complex numbers
    Complex resultMultiplication = complex1 * complex2;

    // Print the results
    std::cout << "Result of addition:" << std::endl;
    resultAddition.Print();

    std::cout << "\nResult of multiplication:" << std::endl;
    resultMultiplication.Print();

    // Use the overloaded != operator to check inequality
    if (complex1 != complex2) {
        std::cout << "\nComplex numbers are not equal." << std::endl;
    } else {
        std::cout << "\nComplex numbers are equal." << std::endl;
    }

    return 0;
}

//Complex Complex::operator/(Complex a)
{
    Complex t;
    double denominator = a.Real * a.Real + a.Imaginary * a.Imaginary;
    t.Real = (Real * a.Real + Imaginary * a.Imaginary) / denominator;
    t.Imaginary = (Imaginary * a.Real - Real * a.Imaginary) / denominator;
    return t;
}



/*
 Task:
 Generate the driver file (main.cpp) where you perform the following tasks. Note that you cannot make any change to
 the header file or the source file.

 Operations to be performed:
    • Create a list of integers.
    • Insert four items.
    • Print the list.
    • Print the length of the list.
    • Insert one item.
    • Print the list.
    • Retrieve 4 and print whether found or not.
    • Retrieve 5 and print whether found or not.
    • Retrieve 9 and print whether found or not.
    • Retrieve 10 and print whether found or not.
    • Print if the list is full or not.
    • Delete 5.
    • Print if the list is full or not.
    • Delete 1.
    • Print the list.
    • Delete 6.
    • Print the list.

    • Write a class "studentInfo" that represents a student record. It must have variables to store the student ID,
    student’s name and student’s CGPA. It also must have a function to print all the values. You will also need to
    overload a few operators.
        • Create a list of objects of class "studentInfo".
        • Insert 5 student record.
        • Delete the record with ID15467.
        • Retrieve the record with ID 13569 and print whether found or not along with the entire record.
        • Print the list.

 Note:
 Helper functions are created to avoid code duplication. You can use them, or you can write your own.
*/
#ifndef STUDENTINFO_H_INCLUDED
#define STUDENTINFO_H_INCLUDED

#include <iostream>
#include <string>

class studentInfo {
public:
    // Constructor
    studentInfo(int id = 0, std::string name = "", double cgpa = 0.0);

    // Function to print student information
    void printInfo() const;

    // Getter for student ID
    int getID() const;

    // Overloaded equality operator
    bool operator==(const studentInfo& other) const;

private:
    int studentID;
    std::string studentName;
    double studentCGPA;
};

#endif // STUDENTINFO_H_INCLUDED
#include "studentInfo.h"

// Constructor definition
studentInfo::studentInfo(int id, std::string name, double cgpa) :
    studentID(id), studentName(name), studentCGPA(cgpa) {}

// Function to print student information
void studentInfo::printInfo() const {
    std::cout << "Student ID: " << studentID << std::endl;
    std::cout << "Student Name: " << studentName << std::endl;
    std::cout << "Student CGPA: " << studentCGPA << std::endl;
}

// Getter for student ID
int studentInfo::getID() const {
    return studentID;
}

// Overloaded equality operator
bool studentInfo::operator==(const studentInfo& other) const {
    return (studentID == other.studentID);
}
#include <iostream>
#include "studentInfo.h"
#include "unsortedtype.h"
#include "unsortedtype.cpp" // Including the implementation file for template class

int main() {
    // Create studentInfo objects
    studentInfo student1(12345, "John Doe", 3.5);
    studentInfo student2(15467, "Jane Smith", 3.7);
    studentInfo student3(13569, "Alice Johnson", 3.9);
    studentInfo student4(17684, "Bob Anderson", 3.2);
    studentInfo student5(19876, "Emily Brown", 3.8);

    // Create a list of studentInfo objects
    UnsortedType<studentInfo> studentList;

    // Insert student records into the list
    studentList.InsertItem(student1);
    studentList.InsertItem(student2);
    studentList.InsertItem(student3);
    studentList.InsertItem(student4);
    studentList.InsertItem(student5);

    // Delete the record with ID 15467
    studentList.DeleteItem(studentInfo(15467));

    // Retrieve and print whether record with ID 13569 is found or not
    studentInfo searchItem;
    bool found = false;
    studentList.RetrieveItem(studentInfo(13569), found);
    std::cout << "Record with ID 13569 is ";
    if (found) {
        std::cout << "found:" << std::endl;
        searchItem.printInfo();
    } else {
        std::cout << "not found." << std::endl;
    }

    // Print the list of student records
    std::cout << "\nList of student records:" << std::endl;
    int length = studentList.LengthIs();
    studentInfo studentRecord;
    for (int i = 0; i < length; ++i) {
        studentList.GetNextItem(studentRecord);
        studentRecord.printInfo();
        std::cout << std::endl;
    }

    return 0;
}